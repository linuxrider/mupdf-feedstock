diff --git a/scripts/wrap/__main__.py b/scripts/wrap/__main__.py
index 4e44e0c17..c0cf30ab6 100644
--- a/scripts/wrap/__main__.py
+++ b/scripts/wrap/__main__.py
@@ -1404,21 +1404,26 @@ def build_so_windows(
         vs = wdev.WindowsVS()
     path_cpp_rel = os.path.relpath(path_cpp)
     path_o = f'{path_cpp}.o'
+
     # Compile.
-    command = textwrap.dedent(f'''
-            "{vs.vcvars}"&&"{vs.cl}"
+    #
+    # We use a response file for cl.exe arguments to avoid exceeding the
+    # Windows cmd.exe command line length limit (~8191 characters), which
+    # can be hit when paths are long (e.g. in conda-forge CI environments).
+    #
+    cl_args = textwrap.dedent(f'''
                 /D "UNICODE"
                 /D "_UNICODE"
                 /D "_WINDLL"
                 /EHsc
                 /Fo"{path_o}"
-                /GS # Buffer security check.
+                /GS
                 /O2
                 /Tp"{path_cpp_rel}"
-                /W3 # Warning level, IDE default.
-                /Zi # Debug Information Format
+                /W3
+                /Zi
                 /bigobj
-                /c                          # Compile without linking.
+                /c
                 /diagnostics:caret
                 /nologo
                 /permissive-
@@ -1426,34 +1431,50 @@ def build_so_windows(
                 {'/D MEMENTO' if memento else ''}
             ''')
     if sys.maxsize != 2**31 - 1:
-        command += f'  /D "WIN64"\n'
+        cl_args += f'  /D "WIN64"\n'
     for define in defines:
-        command += f'    /D "{define}"\n'
+        cl_args += f'    /D "{define}"\n'
     for include in includes:
-        command += f'    /I"{include}"\n'
-    infiles = [path_cpp] + list(includes)
+        cl_args += f'    /I"{include}"\n'
+
+    # Write args to a response file and pass @file to cl.exe.
+    rsp_path = f'{path_o}.rsp'
+    jlib.fs_ensure_parent_dir(rsp_path)
+    jlib.fs_update(cl_args, rsp_path)
+    command = f'"{vs.cl}" @"{rsp_path}"'
+
+    infiles = [path_cpp, rsp_path] + list(includes)
     jlib.build(
             infiles,
             path_o,
             command,
             force_rebuild,
             )
-    # Link
-    command = textwrap.dedent(f'''
-            "{vs.vcvars}"&&"{vs.link}"
-                /DLL                    # Builds a DLL.
-                /IMPLIB:"{path_lib}"    # Name of generated .lib.
-                /OUT:"{path_so}"        # Name of generated .dll.
+
+    # Link.
+    #
+    # Also use a response file for the linker.
+    #
+    link_args = textwrap.dedent(f'''
+                /DLL
+                /IMPLIB:"{path_lib}"
+                /OUT:"{path_so}"
                 {'/DEBUG' if (debug or memento) else ''}
                 {path_o}
             ''')
     for lib in libs:
-        command += f'    "{lib}"\n'
+        link_args += f'    "{lib}"\n'
     for libpath in libpaths:
-        command += f'    /LIBPATH:"{libpath}"\n'
+        link_args += f'    /LIBPATH:"{libpath}"\n'
     if export:
-        command += f'    /EXPORT:{export}'
-    infiles = [path_o] + list(libs)
+        link_args += f'    /EXPORT:{export}\n'
+
+    rsp_path = f'{path_so}.rsp'
+    jlib.fs_ensure_parent_dir(rsp_path)
+    jlib.fs_update(link_args, rsp_path)
+    command = f'"{vs.vcvars}"&&"{vs.link}" @"{rsp_path}"'
+
+    infiles = [path_o, rsp_path] + list(libs)
     jlib.build(
             infiles,
             path_so,
